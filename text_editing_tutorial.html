<!DOCTYPE html>
<html>
<head>
<title>text_editing_tutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>Introduction to text and file editing</h1>
<p>Author: Anne Sonnenschein 
Created: 11/13/2015
Updated: 2/27/2018</p>
<p>This tutorial is designed to give a brief introduction to text editing and file editing, using regular expressions and command line tools. Several exercises were modified from other sources-- primarily Practical Computing for Biologists by Haddock and Dunn-- which are referenced at the end of the file. </p>
<h2>Overview</h2>
<p>In this tutorial, you will learn syntax for simple regular expressions, and how to implement them in text editors. This will be extended to using regular expressions as a command line search tool (grep), and using simple sed and awk commands to search, modify and reorganize files without opening them. This tutorial is barely scratching the surface of what can be done with these tools. To learn more, please see the references listed at the end!</p>
<h2>Background</h2>
<h3>What is Regex?</h3>
<p>Regular expressions (or regex) are a language for search and replace. They allow search for wild-cards: characters that can match more than one string. This can be especially useful for text editing, or converting large files from one format to another. Regular expressions are enabled in some text editors, and many programming languages (notably Python and Perl). In Unix they are implemented in tools such as grep and sed. The syntax is generally common across platforms.</p>
<h3>What is sed?</h3>
<p>Sed allows you to search and replace the contents of a file without opening it. It also enables searching and editing multiple files simultaneously. Simple sed commands are run from the command line, but it can also be incorporated into shell script for more complicated tasks.</p>
<h3>What is awk?</h3>
<p>Awk can be used to make complex alterations to a file's organization (e.g. re-ordering columns, converting columns to rows). Like with sed, awk can be invoked from the command line, but is usually incorporated into shell scripts. It is very fast, and very powerful. Most things you would do with awk could be scripted using loops in python, but if you're modifying large files, there is <strong>no comparison</strong> when it comes to speed.</p>
<h2>Regex using text editors</h2>
<p>For this part of the activity you will need a text editor with regular expressions enabled. For the exercise at the end, you will need either Python or Perl.</p>
<p>TextWrangler (Mac) 
http://www.barebones.com/products/textwrangler/download.html</p>
<p>Notepad++ (Windows) 
https://notepad-plus-plus.org/download/v6.8.6.html</p>
<h3>Getting started</h3>
<p>The first piece of data we will use is this list of species:</p>
<ol>
<li>Drosophila melanogaster</li>
<li>Drosophila simulans</li>
<li>Drosophila sechellia</li>
<li>Anopheles gambiae</li>
<li>Aedes aegypti</li>
<li>Tribolium castaneum</li>
<li>Apis mellifera</li>
</ol>
<p>Copy this list into your text editor.</p>
<p>If you are using TextWrangler, select Find from the Search menu, and check the option &quot;Grep&quot;.</p>
<p>If you are using Notepad++, select Replace... from the Search menu, and check the option &quot;Regular expressions&quot;.</p>
<p>The first thing we will do is look at which parts of the list correspond to 'wildcards' </p>
<h3>Wildcards</h3>
<h6>Basic wildcards</h6>
<p>\w : indicates letters, numbers and underscores
\d : indicates digits from 0-9
\D : indicates any character <strong>except</strong> digits
\t : indicates tab
\s : indicates white space or new line character
\S : indicates any character <strong>except</strong> white space
\r: indicates carriage return
\n: indicates line-feed
.: indicates any character or white space</p>
<p>The backslash- \ - is called an 'escape'. It indicates a 'special' meaning of the following term. </p>
<p>Using the 'search' option, but without replacing, look at what you get when you search \w. This search term should match with each individual letter and number, but not the white spaces or punctuation.</p>
<p>Look at the results when you search \d, \r, \n, or \r\n.</p>
<p>Depending on the operating system and/or text editor, new lines may be indicated by \r, \n, or \r\n.</p>
<p>Let's remove the numbers. Enter \d for search, and leave replace blank.</p>
<p>Now your list should look like:</p>
<p><code>. Drosophila melanogaster
. Drosophila simulans
. Drosophila sechellia
. Anopheles gambiae
. Aedes aegypti
. Tribolium castaneum
. Apis mellifera</code></p>
<p>Now lets get rid of the dots. See what happens if you search . and leave replace empty.</p>
<p>That was fun! Now type command-z (mac) or ctrl-z (windows) to restore your text.</p>
<p>When regular expressions are enabled, . matches any character. When you want to search a character that matches a wildcard/special character, preface it with a backslach. If the special character <strong>is</strong> a backslash, your escape will be a second backslash (e.g. \)</p>
<p>To remove the periods, search . and replace with blank.</p>
<p>Now your list should look like:</p>
<p><code>Drosophila melanogaster
 Drosophila simulans
 Drosophila sechellia
 Anopheles gambiae
 Aedes aegypti
 Tribolium castaneum
 Apis mellifera</code></p>
<p>There's still an extra blank space before the genus names. What wild card will you search for to remove it?</p>
<p>What went wrong?</p>
<p>\s matches to white space, or new-lines. To get around this, search \r\n\s, and replace with \r\n. Manually fix the first line.</p>
<p>Now figure out how to move all the elements of the list onto one line, separated by commas.</p>
<h3>Quantifiers</h3>
<p>Adding a + to a wild card allows it to match multiple occurrences of that card in succession.</p>
<p>If you want to match multiple word-characters in a row, you will search \w+</p>
<p>Multiple-digit numbers can be found with \d+</p>
<p>If you want to preserve a wild-card character that you're searching, bracket it with parentheses.</p>
<p>Let's change the 'Genus species' nomenclature to 'G. species'.</p>
<p>Search (\w)\w+ and replace with \1.</p>
<p>Now your list should look like
<code>D. melanogaster, D. simulans, D. sechellia, A. gambiae, A. aegypti, T. castaneum, A. mellifera</code></p>
<h3>Invisible characters</h3>
<p>It can be difficult to tell \r from \r\n, or tab characters from white space. You can see these 'invisible characters' by adjusting the settings in your text editor.</p>
<h5>Adjust settings in TextWrangler:</h5>
<p>Select View -&gt; Text Display -&gt; Show Invisibles</p>
<h5>Adjust settings in notepad ++:</h5>
<p>View -&gt; Show Symbol -&gt; Show All Characters</p>
<h3>Text editor exercise</h3>
<h4>Exercise 1</h4>
<p>Open the file &quot;twenty_seven_club.txt&quot;</p>
<p>There's a superstition about musicians dying at age twenty-seven, that became well known after the deaths of well-known singers like Kurt Cobain and Amy Winehouse. This list (taken from wikipedia) contains a full list of musicians who died at the age of twenty-seven.</p>
<p>Notice how words are separated by white space, and categories are separated by tabs. </p>
<p>Replace the full date in the second column with just the year, using the following commands:</p>
<p>Search: (\w+)\t\w+\s\d+,\s
Replace: \1\t</p>
<p>Now figure out how to remove all information on each line after the year (cause of death, age, etc.)</p>
<p><img src="https://4.bp.blogspot.com/-cspkAL2F2bM/VsFgLh5ZYxI/AAAAAAAABgo/jRmPWLZasVA/w1200-h630-p-k-no-nu/xkcd.png" alt="XKCD link 1" /></p>
<p>** from https://xkcd.com/1638/</p>
<h2>Using regex in the command line with grep</h2>
<p>Open your choice of unix command line terminals. Make sure you're in the correct directory!
The syntax for regular expressions in grep is a little different than in text editors, but much of what you've learned will translate.</p>
<h3>Finding a literal string in a file, and counting the number of matches</h3>
<p>Let's start by finding Kurt Cobain. Use the following command:
<code>grep Kurt twenty\_seven\_club.txt</code>
This will also work (regular expressions!):</p>
<p>````
grep Kurt *.txt
```</p>
<p>Now find everyone in the file who died of overdoses.</p>
<p>You can also use grep to count the total number of matches</p>
<p>````
grep -c overdose twenty_seven_club.txt
```</p>
<h3>Inverting a match</h3>
<p>Now lets use grep to count how many members of the 'twenty seven club' who died of things OTHER than overdoses. Using the option -v allows you to invert the match.</p>
<p>````
grep -cv overdose twenty_seven_club.txt
```</p>
<h3>Searching across multiple files</h3>
<p>Now we're going to transfer these skills to looking at files generated by bioinformatic programs. In the folder Coding_sequence_alignment are a series of output files from Blastn alignments. These are comparisons of the exon coding sequence of a gene from <em>Drosophila melanogaster</em> with the genomes for other species in the Drosophila genus. Take a look at these files using the 'more' or 'head' command. </p>
<p>Let's find the match percentage from each file. Grep for the % symbol. In the command line, * indicates 'any character'. So here, we're grepping the %, in files whose filenames end in .out.</p>
<p><code>grep % *.out</code></p>
<h3>Searching with regular expressions</h3>
<p>The codon for the amino acid methionine is ATG.
There are four codons that code for the amino acid arginine: CGA, CGT, CGG, CGC.</p>
<p>Lets find every instance of an ATG followed by an arginine. For an A, T, C or G, use [ACGT].</p>
<p><code>grep ATGCG[ACGT] *.out</code></p>
<h3>Searching lines after a line</h3>
<p>Maybe we want just the first line of each alignment, as below:</p>
<blockquote>
<p>Query  1         ATGGATAGCAGCAGCGAACAGTTGAACGGATCGGGAGCTTTGAATTTCAAGCGGCCCAAG  60</p>
<p>Sbjct  14154092  ATGGATAGCAGCAGCGAACAGTTGAACGGCTCGGGAGCTTTAAATTTCAAGCGGCCCAAG  14154033</p>
</blockquote>
<p>However, this occupies three lines.</p>
<p>It's reasonably easy to search for &quot;Query  1 &quot;</p>
<p><code>grep &quot;Query  1 &quot; *.out</code></p>
<p>If we also want the two lines following the line containing the match, add the option &quot;-A2&quot;. The A stands for &quot;after&quot;, and the number for the number of lines you want added. &quot;B&quot; instead of &quot;A&quot; would give you the lines before the match.
<code>grep \-A2 &quot;Query  1 &quot; *.out</code></p>
<h2>Using sed to alter files in the command line</h2>
<p>Sed can be used to reformat files (double-space them, number them), or copy files with reformatting into a new file. However, it's most common use in my experience is for find and replace.</p>
<p>Find-and-replace actions are going to generally be formatted like:</p>
<blockquote>
<p>sed 's/pattern you are finding/what you're replacing/' filename(s)</p>
</blockquote>
<p>Let's replace every instance of &quot;Query&quot; with the name of the Query species, D.melanogaster</p>
<p><code>sed 's/Query/D.melanogaster/' *.out</code></p>
<p>Currently, it's outputting the modified files to the command line. If we want to edit the files themselves, use the option -i
<code>sed -i 's/Query/D.melanogaster/' *.out</code></p>
<p>Be careful doing this, especially when you're modifying more than one file at a time. This cannot be reversed!</p>
<p>Some of the sequence in the alignment is uppercase, and some is lowercase. Let's convert it all to uppercase. </p>
<p><code>sed -i 's/.*/\U&amp;/' *.out</code>
the period tells it to match all characters, the * tells it it's matching any number of all characters</p>
<p>the backslash U is replacing it with uppercase, and the ampersand is an indicator that it should be replacing ALL matches (essentially, it's making this replacement globally)</p>
<h2>Using awk to alter files in the command line</h2>
<p>Awk statements follow the pattern of:</p>
<blockquote>
<p>awk 'pattern {action we're performing on the pattern}'</p>
</blockquote>
<p>If you don't include a pattern, it will match every line.</p>
<p>This statement will number every line (including empty lines):</p>
<blockquote>
<p>awk '{print FNR &quot;\t&quot; $0}' *.out</p>
</blockquote>
<p>We aren't matching a pattern, so it's doing every line. FNR is a special character, instructing it to print line numbers. The tab wildcard tells it to put a tab between the number and the line itself, and the $0 is instructing it to do this with the whole line.</p>
<p>If we wanted to remove all duplicate lines (not really a problem with this file, but certainly with many datatables!) we would use this command:</p>
<blockquote>
<p>awk '!a[$0]++' filename</p>
</blockquote>
<p>If we only wanted to remove duplicate <em>consecutive</em> lines, we would use this command:</p>
<blockquote>
<p>awk 'a != $0; {a = $0}' filename</p>
</blockquote>
<p>Awk is very idiomatic. When I need to use it, I usually just copy lines out of books or off of stackexchange. However, it can do basically anything to a file (including the things we've done so far with sed and grep), and much more besides. If you need to manipulate huge files on a regular basis, it is probably worth investing the time to learn how it works.</p>
<h4>Exercise 2</h4>
<p>Open the gff file &quot;example.gff&quot;. gffs are flat text files containing genomic features, that can be opened in any text editor. </p>
<p>The first few lines are headers. The informative lines all look like:</p>
<p><code>chr2L	macs	peak\_call	214988	216272	6.38	.	.	Summit=826;Tags=82;pval=159.43;fdr=6.38</code></p>
<p>Bedgraphs are another file format frequently for genomic data. They can be opened in most genome browsers, like the UCSC genome browser and IGV. This line in bedgraph format would include the chromosome, coordinates, and score (summit). It would look like:</p>
<p><code>chr2L	214988	216272	826</code></p>
<p>Change the information in this file from gff format to bedgraph format. You can use any combination of text-editors, sed, and awk.</p>
<p><img src="https://78.media.tumblr.com/344ffa782f879934acc93f0d208a395c/tumblr_p4udozJoRq1twu60xo1_1280.png" alt="XKCD link 2" /></p>
<p>** from https://xkcd.com/208/</p>
<h4>References</h4>
<p>Haddock and Dunn, 2011. Practical Computing for Biologists, chapter 2</p>
<p>https://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples</p>
<p>Dale Dougherty, Arnold Robbins, sed &amp; awk, 2nd Edition
Publisher: O'Reilly Media</p>
<p>Peter Krumins, Sed one liners explained</p>
<p>Peter Krumins, Awk one liners explained</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
